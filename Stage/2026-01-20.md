---
cssclasses:
  - martedi
tags:
  - ingress
  - configmap
  - swagger
  - port-forward
  - AKS
  - kubectl
  - Kubernetes
  - container
  - release
  - temp_ingress
  - gateway
  - appsettings
---

## mattina
aggiornare il wiki

Qui sotto ti propongo **una versione aggiornata, coerente con quello che avete appena fatto**, senza riscriverlo da zero ma **correggendo i punti che oggi sarebbero fuorvianti**.

Ho applicato queste regole:
- path senza trattini, tutto attaccato (`partnumbers`, `technicalpubs`, …)
- distinzione **chiara** tra `temp` (accesso diretto) e `fleet` (via BFF, autenticato)
- nota esplicita sui 401 su fleet (attesi)
- swagger: quando funziona via gateway e quando no
---
### Premessa: indirizzo `temp`

Per accedere direttamente ai servizi (senza passare dal BFF) è stato allestito l’indirizzo:

```
temp.afm.vvf.priv
```

È necessario aggiungere al file `hosts` la seguente entry:

```
9.235.123.140   temp.afm.vvf.priv
```

> ⚠️ Nota  
> L’accesso tramite `temp` non applica autenticazione centralizzata.  
> Alcuni swagger funzionano, altri no, in base alla configurazione interna del singolo servizio, fatta nel program.cs.

---

### Accesso con autenticazione (BFF Gateway)

L’accesso standard all’applicazione passa dal BFF Gateway:
https://fleet.afm.vvf.priv/

Per utilizzarlo è necessario:
- collegarsi alla VPN Azure
- aggiungere al file `hosts`:
```
9.235.123.140   fleet.afm.vvf.priv
9.235.123.140   keycloak.afm.vvf.priv
```

>  Nota  
> Gli endpoint `fleet.afm.vvf.priv/api/**` sono protetti.
> L’accesso diretto agli swagger tramite `fleet` può restituire **HTTP 401 (Unauthorized)** ed è un comportamento **atteso**.

---

### Accesso allo Swagger tramite port-forward
Se lo swagger non è raggiungibile tramite `temp` o `fleet`, è possibile usare il port-forward Kubernetes.
Esempio (Part Numbers):
```bash
kubectl port-forward svc/afm-mn-partnumbers-service 5011:80
```
Swagger disponibile su:
```
http://localhost:5011/swagger/index.html
```

---
#### VVF-FE
Il servizio Front-End è deployato su AKS.
##### Front-End
URL:
```
https://fleet.afm.vvf.priv/
```
Prerequisiti:
- VPN Azure attiva
- file `hosts`:
    ```
    9.235.123.140   fleet.afm.vvf.priv
    ```
---
#### PART NUMBERS
Servizio deployato su AKS.
##### Front-End
https://fleet.afm.vvf.priv/api/partnumbers
https://temp.afm.vvf.priv/api/partnumbers
##### Back-End
Service:
```
afm-mn-partnumbers-service
```
##### Swagger
Via indirizzo:
https://temp.afm.vvf.priv/api/partnumbers/swagger/index.html
-> da errore parse 


In alternativa (consigliato se non risponde):
```bash
kubectl port-forward svc/afm-mn-partnumbers-service 5011:80
```
e poi 
http://localhost:5011/swagger/index.html

---
#### SERIAL NUMBERS
Servizio deployato su AKS.
##### Front-End
```
https://fleet.afm.vvf.priv/api/serialnumber
https://temp.afm.vvf.priv/api/serialnumber
```
##### Back-End
Service:
```
afm-mn-serialnumbers-service
```
##### Swagger
Lo swagger non è sempre esposto correttamente via Ingress/BFF.  
Usare preferibilmente il port-forward:
```bash
kubectl port-forward svc/afm-mn-serialnumbers-service 5021:80
```

```
http://localhost:5021/swagger/index.html
```

---
#### BACKEND IAS (afm-ms-backend)
Servizio temporaneo (monolite backend).
##### Front-End
https://fleet.afm.vvf.priv/api/afm-ms-backend
https://temp.afm.vvf.priv/api/afm-ms-backend
##### Back-End
Service:
```
afm-ms-backend-service
```
##### Swagger
https://temp.afm.vvf.priv/api/afm-ms-backend/swagger/index.html
---
#### TECHNICAL PUBS
Servizio deployato su AKS.
##### Front-End
https://fleet.afm.vvf.priv/api/technicalpubs
https://temp.afm.vvf.priv/api/technicalpubs
##### Back-End
Service:
```
afm-mn-technicalpubs-service
```
##### Swagger
https://temp.afm.vvf.priv/api/technicalpubs/swagger/index.html

---
#### WAREHOUSE
##### Front-End
https://fleet.afm.vvf.priv/api/warehouse
https://temp.afm.vvf.priv/api/warehouse

##### Back-End
Service:
```
afm-wh-warehouse-service
```

##### Swagger
Non ancora esposto in modo stabile.  
Usare port-forward quando necessario.



### Nota finale
- `temp.afm.vvf.priv` → accesso diretto ai servizi (debug / test)
- `fleet.afm.vvf.priv` → accesso ufficiale via BFF (autenticato)
- gli HTTP 401 su fleet sono normali
- lo swagger non è uniforme tra i servizi
    
usando il `bff-gateway-config` andrà esattamente così com’è ora.**  
E quindi:
- gli swagger via BFF continueranno a dare 401
- non è un bug
- **è il comportamento corretto con l’autenticazione attiva**
---

## Perché via BFF sempre 401 (ed è giusto)
Il BFF Gateway fa queste cose (per design):
1. È un OAuth2 client
2. Propaga il token (`TokenRelay`)
3. Protegge `/api/**`


Quindi quando si prova, ad esempio:

```
https://fleet.afm.vvf.priv/api/partnumbers/swagger/index.html
```
succede questo:
- la richiesta **entra nel BFF**
- **non c’è una sessione autenticata 
- non c’è un token valido
- Spring Security risponde 401 Unauthorized

 Questo **è voluto**.
Lo swagger **non è un utente**, non fa login, non ha token.

---
## Perché via `temp` a volte va
Perché:
- `temp.afm.vvf.priv` bypassa il BFF
- non c’è OAuth2
- non c’è `TokenRelay`
- sei “dentro rete” → il servizio risponde se è configurato bene
Ma questo **non è il modello finale**.
---
## Quindi: cosa succederà “a regime” col BFF?
##### Stato attuale
- BFF = accesso applicativo
- Swagger = strumento di sviluppo
- Swagger **non passa dal BFF**
 Swagger via BFF **NON è previsto**.
---
## Se un giorno voleste lo swagger via BFF (opzionale)
Tecnicamente si può, ma **è una scelta esplicita**, non automatica.
Servirebbe tutto questo:

1. **Escludere swagger dalla security del BFF**, tipo:
    ```yaml
    /api/**/swagger/**
    /api/**/v3/api-docs/**
    ```
2. Disabilitare `TokenRelay` su quelle route
3. Gestire correttamente `X-Forwarded-*`
4. Accettare che:
    - swagger sia pubblico
    - oppure protetto diversamente
        
non è gratis, e spesso **non è desiderabile** in ambienti reali.

---

#### Collegamento con il problema Warehou
Per Warehouse:
- manca proprio `/v3/api-docs`
- quindi anche se togliessi l’autenticazione dal BFF
- non funzionerebbe comunque
    
Quindi non stai “perdendo” nulla.

---
#### Risposta definitiva
> “usando poi bff-gateway-config, lì andrà così com’è?”

**Sì. E va bene così.**
- 401 sugli swagger via `fleet` → **atteso**
- swagger da usare:
    - via `temp` _quando funziona_
    - via **port-forward** quando non funziona
        
- BFF usato per:
    - FE
    - API applicative
    - sicurezza

---

> ⚠️ **Swagger e BFF**  
> Gli endpoint swagger non sono accessibili tramite `fleet.afm.vvf.priv` poiché il BFF applica autenticazione OAuth2.  
> Questo comportamento è intenzionale. Per la documentazione API usare `temp.afm.vvf.priv` o il port-forward.


## pomeriggio
rilasciare nuovamente:
pipeline che hanno girato di recente
fatto.
serialnumbers monta il volume diversamente dagli altri facendo initcontainer e command -sh ecc (nel deployment)

Qui **le differenze ci sono eccome**, e sono **architetturali**, non cosmetiche.
Tolto il fatto che sono due servizi diversi, ecco cosa cambia davvero tra le due #deployment.

---
La differenza più importante è come viene gestita la configurazione ( #appsettings)**.

Nel **technicalpubs**:

- usa #ConfigMap montata direttamente come file
    
- `appsettings.json` viene montato con:
    - `subPath`
    - `readOnly: true`
        
- il file finisce **direttamente in `/app/appsettings.json`**
    
- **non c’è initContainer**
    
In pratica:  
il container parte **già con la configurazione pronta**  
Kubernetes monta il file al runtime

---

Nel **serialnumbers** invece:

- **NON monta direttamente il file**
    
- usa un **initContainer (`busybox`)**
    
- il flusso è:
    
    1. ConfigMap montata in `/tmp`
        
    2. initContainer fa:
        
        ```
        mkdir -p /app/config
        cp /tmp/appsettings.json /app/config/
        ```
        
    3. il container principale legge il file da volume persistente
        

In pratica:  
la configurazione viene **copiata fisicamente** prima che l’app parta  
il file diventa **scrivibile e persistente**

Questa è la differenza più grossa.

---

Seconda differenza: **initContainer sì / initContainer no**

- **technicalpubs**: nessun initContainer
    
- **serialnumbers**:  initContainer presente
    

Conseguenze:

- `serialnumbers` ha **una fase di bootstrap**
    
- se l’initContainer fallisce → **il Pod non parte**
    
- `technicalpubs` è più semplice e diretto
    

---

Terza differenza: **porte e ASPNETCORE_URLS**

- **technicalpubs**
    
    - esplicita `ASPNETCORE_URLS`
        
    - porta dichiarata coerente (`8080`)
        
- **serialnumbers**
    
    - **non** esplicita `ASPNETCORE_URLS`
        
    - probabilmente usa:
        
        - default .NET
            
        - oppure configurazione interna/appsettings
            

Quindi:  
`technicalpubs` è più **esplicito**  
`serialnumbers` si affida di più all’immagine/app

---

Quarta differenza: **modalità di uso del volume**

- **technicalpubs**
    
    - volume usato come storage
        
    - config separata, readonly
        
- **serialnumbers**
    
    - stesso volume usato **anche per ospitare la config**
        
    - config **scritta** dentro il volume
        

Questo implica:

- `serialnumbers` può **modificare o sovrascrivere** la config
    
- `technicalpubs` no (immutabile)
    

---

Quinta differenza: **robustezza vs semplicità**

Riassunto concettuale:

- **technicalpubs**
    
    - più “cloud-native”
        
    - ConfigMap → mount diretto
        
    - meno moving parts
        
    - più facile da manutenere
        
- **serialnumbers**
    
    - approccio più “legacy”
        
    - copia fisica del file
        
    - initContainer = più controllo, ma più complessità
        

---

### TL;DR secco

Le vere differenze sono:

1. **ConfigMap montata direttamente** vs **ConfigMap copiata con initContainer**
    
2. **Nessun initContainer** vs **initContainer obbligatorio**
    
3. **Config readonly** vs **config scrivibile/persistente**
    
4. **Bootstrap semplice** vs **bootstrap a due fasi**
    
5. **Approccio moderno** vs **approccio più manuale**
    



