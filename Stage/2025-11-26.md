---
tags:
---
#### teseo
teseo / sait 
deploy di teseo (qualcuno risolverà il problema di sait)

#### vvf
VVF_FE
VVF_SerialNumbers



#### conteinerizzazione 

contenerizzazione con Docker 
deploy > kubernetes (orchestratore)
creazione dei file yaml 

###### Come si creano i container per un applicativo (in Azure DevOps)
Per creare un container servono **3 passaggi fondamentali**:

**1️. Scrivere un Dockerfile**

È un file di istruzioni che dice:
* quale immagine base usare (es. `node:18`, `python:3.12`, `mcr.microsoft.com/dotnet/aspnet:8`)
* come copiare il codice nel container
* quali porte esporre
* quale comando eseguire all’avvio

Esempio:
```dockerfile
FROM node:18
WORKDIR /app
COPY . .
RUN npm install
CMD ["npm", "start"]
```

**2️ Costruire l’immagine (build)**

In locale:
```bash
docker build -t mia-app:1.0 .
```

Nel mondo **Azure DevOps CI**: 
* pipeline YAML con step `Docker@2` che fa il build
* output → immagine pronta

**3️ Salvare l’immagine in un registry**
I registry più usati:
* **ACR (Azure Container Registry)** → integrato con Azure DevOps
* Docker Hub
* GitHub Container Registry

Esempio push:
```bash
docker push acr.azurecr.io/mia-app:1.0
```

Solo quando l’immagine è nel registry può essere usata da Kubernetes, OKD, ECS, Docker Swarm ecc.

---

###### Cosa sono i Pod 

Un Pod è l’unità minima di esecuzione di Kubernetes.
Contiene **uno o più** container che:
* condividono IP
* condividono porte
* condividono storage (volumi) .. tra i file yaml di configurazione esistono questi volumi, persistent 
* condividono **ciclo di vita**

È Kubernetes (non Docker) che decide **dove** far girare il Pod nel cluster.

Un Pod può contenere:
* un container principale
* container sidecar (es. logger, proxy)
* init-container (per preparare l’ambiente)

###### Come si organizzano i Pod? 

 **A) Kubernetes (lo standard)**
* Pod gestiti tramite **Deployment**, **ReplicaSet**, **Service**, **Ingress**, **ConfigMap**, **PVC** ecc.
* Scheduler che decide dove eseguirli
* Scalabilità automatica
È il più potente… ma anche **il più complesso da amministrare**.

oppure, NON è il nostro caso
 **B) Docker “puro” (solo container, senza Pod)**
* Solo `docker run`
* Non esistono Pod
* Non esiste orchestrazione
* Non esiste scaling automatico

qui nel progetto VVF non si usa OKD (kubernetes openshift) come in TESEO..OKD è solo una versione open-source di OpenShift.
Non è necessaria per usare Azure.

Se NON si usa OKD, cosa si può usare con Azure?
In Azure le alternative principali sono:
* **AKS (Azure Kubernetes Service)** → Kubernetes gestito


I principali file YAML sono:

| Oggetto                           | Funzione                       |
| --------------------------------- | ------------------------------ |
| **Deployment**                    | Come creare e scalare i Pod    |
| **Service (svc)**                 | Espone i Pod alla rete         |
| **ConfigMap**                     | Configurazioni NON sensibili   |
| **Secrets**                       | Configurazioni sensibili       |
| **Ingress**                       | Gestisce il routing HTTP/HTTPS |
| **PV (Persistent Volume)**        | Storage nel cluster            |
| **PVC (Persistent Volume Claim)** | Richiesta di storage           |
| **Namespace**                     | Separazione logica di ambienti |

Esempio Deployment YAML:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mia-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mia-app
  template:
    metadata:
      labels:
        app: mia-app
    spec:
      containers:
      - name: main
        image: acr.azurecr.io/mia-app:1.0
        ports:
        - containerPort: 80
```


Con kubectl puoi:

```bash
kubectl apply -f deployment.yaml
kubectl get pods
kubectl logs nome-pod
kubectl describe pod nome-pod
kubectl delete -f .
kubectl exec -it nome-pod -- bash
```

È lo strumento principale di amministrazione (sia per Kubernetes che per OKD/OpenShift).

e kubectl è il comando CLI ufficiale per comunicare con un cluster Kubernetes, applicare file YAML, gestire i #pod, controllare lo stato del cluster e fare debugging.

