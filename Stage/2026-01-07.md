---
cssclasses:
  - mercoledi
tags:
  - swagger
  - container
  - "#targetport"
  - clusterIP
  - localhost
  - servizi
  - port-forward
  - URL
  - ingress
  - "#temp_ingress"
---

rientro.

accesso teams negato (licenza).


guardo warehouse novità...
-Application
-Domain
-Infrastucture

l'ultima cosa fatta (da me) è la pipeline del 18/12 e il deploy del 19/12...

poi in application sono state fatte le Commands / Queries / Values/Request





### Vedere lo Swagger nel browser
Il problema non era lo Swagger.  
Il problema era **capire da dove passa il traffico**.

###### 1) Dentro il container
L’applicazione gira **dentro un container**.

Lì dentro:
- l’app ascolta su una **porta interna** ( #targetport 8080)
- è raggiungibile solo da chi può parlare con quel container
    
Importante:  
`localhost` _dentro il container_ ≠ `localhost` sul tuo PC.

---
##### 2) Il Pod
Kubernetes incapsula il container in un Pod.
Il Pod:
- ha un IP proprio (interno al cluster) #clusterIP
- espone la porta del container (8080)
    
Quell’IP non è raggiungibile dal tuo laptop.

---
##### 3) Il Service (ClusterIP)

Il Service che hai è:

- di tipo **ClusterIP**
- con un IP tipo `100.64.x.x`
- espone la porta **80**
- inoltra verso la porta **8080** del Pod
    

In pratica:

```
Service:80  →  Pod:8080
```

Il Service serve a:

- stabilizzare l’IP dei pod
    
- fare routing e load balancing
    
- **non** esporre nulla all’esterno
    

Per design.

---

##### 4) Perché incollare l’IP nel browser non funzionava

Perché:
- il Service è **solo interno**
- l’IP `100.64.x.x` non è routabile dal tuo PC
Quindi il timeout era atteso e corretto.

---

##### 5) Cos’è `kubectl port-forward` (il passaggio chiave)

`kubectl port-forward` crea un tunnel temporaneo:
```
localhost:<porta PC>
        ↓
kubectl
        ↓
Service
        ↓
Pod
        ↓
Container
```

Nel tuo comando:

```
kubectl port-forward svc/afm-mn-partnumbers-service 5011:80
```

succede questo:

```
localhost:5011
  → Service:80
      → Pod:8080
          → App
```

Ecco perché vedi:

```
Forwarding from 127.0.0.1:5011 -> 8080
```

Non è magia: è la catena completa mostrata a schermo.

---

##### 6) Perché lo Swagger è comparso

Perché finalmente:

- la richiesta HTTP è arrivata **davvero all’app**
- sulla porta giusta
- senza blocchi di rete
    

Swagger era già funzionante.  
Non era mai stato raggiunto prima.

---

##### 7) Regola mentale fondamentale (questa conta davvero)

> ClusterIP = solo port-forward dal PC

Finché non usi:
- LoadBalancer
- Ingress (ora abbiamo #temp_ingress)

non esiste un URL “vero” esterno.

---

##### 8) Ordine corretto dei test (da rifare sempre)

Quando deployi un nuovo repo:
1. Pod `Running`
2. `kubectl logs` puliti
3. Service creato
4. `kubectl port-forward`
5. Swagger visibile
    

Solo **dopo**, se serve:

- esposizione esterna
- DNS
- firewall
- ingress

---

##### 9) Perché sembrava tutto confuso prima

Perché stavano cambiando **troppe porte**:
- 80
- 5011    
- 8080
    

---
### Tipi di svc: 
#### ClusterIP 
con port-forward si crea un "tunnel" sicuro dalla macchina al pod e funziona sempre (poi si apre localhost:{porta del service}/swagger/index.html)

```
kubectl port-forward svc/vvf-be-attachments-service 5001:5001 -n vvf
```
##### 1) `kubectl port-forward`
- È un comando che crea un **tunnel temporaneo** tra la tua macchina locale e il cluster Kubernetes.
- Ti permette di accedere **a un pod o a un service** senza esporre il servizio a Internet.
- È molto usato per **debug, test, o per vedere Swagger** senza LoadBalancer.
---

##### 2) `svc/vvf-be-attachments-service`

- Qui specifichi il tipo di risorsa a cui collegarti
- `svc/` significa “Service” (può anche essere un pod: `pod/<nome-pod>`).
- Kubernetes userà il Service per instradare le richieste verso **il pod corretto** dietro il Service.

##### 3) `5001:5001`

- Il formato è **`<porta-locale>:<porta-remote>`**
    - La prima (a sinistra) = porta sulla tua macchina (`localhost:5001`)
    - La seconda (a destra) = porta sul Service/pod (targetPort:5001)
        

In pratica:

```
localhost:5001 → Service:5001 → Pod:5001 → App
```

- Tutto il traffico HTTP che metti su `localhost:5001` viene **instradato dentro il cluster** al pod giusto.

##### 5) Cosa succede quando esegui il comando

1. Kubernetes apre un canale TCP tra la tua macchina e il cluster.
2. Le richieste che metti su `localhost:5001` passano attraverso kubectl e il kube-apiserver.
3. Arrivano al Service `vvf-be-attachments-service`.
4. Il Service fa routing verso il Pod corretto.
5. Il Pod riceve la richiesta sulla porta 5001.
6. La risposta torna indietro lungo lo stesso tunnel al tuo browser.
    

> In pratica, funziona come se la tua macchina fosse dentro il cluster, anche se sei fisicamente fuori.

##### 6) Perché è utile

- Non serve LoadBalancer o Ingress.
- Funziona anche se il Service è `ClusterIP` o LoadBalancer interno.
- Ideale per test, debug, o vedere Swagger senza toccare firewall o VPN.



#### LoadBalancer
invece con LoadBalancer interno (solo se la VPN funziona e il firewall lo permette)

Se la tua macchina vede 172.22.0.74 e la porta 5001 è aperta:
si può fare qualcosa tipo.
`http://172.22.0.74:5001/swagger/index.html`
Altrimenti si riceve timeout.



### Questione config e appsettings


