---
cssclasses:
  - giovedi
tags:
  - replatform
  - "#artifacts"
  - "#pipeline"
  - "#container"
---

giovedi
todo:
deploy di techicalpubs



replatform droni
# build replatform cosa significa 
quello che ho capito. prendere due cartelle che contengono progetti già fatti e funzionanti, inzipparli. creare una pipeline che faccia questo lavoro (all'interno devo dire di prendere tali cartelle, comprimerle in uno zip e poi utilizzarle nella pipeline stessa.) dovrebbe essere simile al procedimento delle pipeline_no_container.yaml che erano di questo tipo: 
```
# VVF_BE_Attachments
# .Net

trigger:

- pipeline_try

resources:
  - repo: self

#name: $(BuildDefinitionName)_$(Year:yyyy).$(Month).$(DayOfMonth)$(Rev:.r)

name: $(major).$(minor).$(release).$(build)


variables:

  #Build info

  solution: 'VVF.AFM.Attachments.sln'

  buildPlatform: 'Any CPU'

  buildConfiguration: 'Debug'

  appxPackageDir: '$(build.artifactStagingDirectory)\AppxPackages\\'

  AppxPackageSigningEnabled: false

  BinSourceFolder: '$(system.defaultworkingdirectory)\VVF.AFM.Attachments.Api\bin'

  #Docker info

  dockerComposeFile: 'docker-compose.yml'

  #Container registry service connection established during pipeline creation

  AzureSubscription: 'MAE AFM-VVF-DEV'

  dockerRegistryName: 'afmvvf.azurecr.io'

  dockerRegistryServiceConnection: 'afmvvf.azurecr.io'

  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'

  imageRepository : 'vvf/be-attachments'

  

  #Versioning

  major: 0

  minor: 0

  release: 1

  build: $[counter(variables['release'], 0)]

  tag: $(major).$(minor).$(release).$(build)

  

  # Agent VM image name

  vmImageName: 'ubuntu-latest'


stages:

  - stage: Build

    displayName: Build and push stage


    jobs:

      - job: Build

        displayName: Builds

        pool:

          vmImage: $(vmImageName)

        steps:

          - checkout: self

  

          # output updated build number

          - pwsh: echo $(Build.BuildNumber) 

          # .Net versione 8.0.x

          - task: UseDotNet@2

            inputs:

              packageType: 'sdk'

              version: '8.0.x' 

  

          # Build

          - script: |

              dotnet nuget list source

            displayName: 'Gestione dei pacchetti NuGet'

  

          - script: dotnet restore

            displayName: 'Restore NuGet packages'

  

# ### NO CONTAINERS

          - task: VSBuild@1

            inputs:

              platform: '$(buildPlatform)'

              solution: '$(solution)'

              configuration: '$(buildConfiguration)'

              msbuildArgs: '/p:AppxBundlePlatforms="$(buildPlatform)" /p:AppxPackageDir="$(appxPackageDir)" /p:AppxBundle=Always /p:UapAppxPackageBuildMode=StoreUpload'

           - task: CopyFiles@2

             displayName: 'Copy Files from: $(BinSourceFolder) to: $(build.artifactstagingdirectory)'

             inputs:

               SourceFolder: '$(BinSourceFolder)'

               Contents: '**'

               TargetFolder: '$(build.artifactstagingdirectory)'

           - task: PublishBuildArtifacts@1

             displayName: 'Publish Artifact: drop'

             inputs:

               PathtoPublish: '$(build.artifactstagingdirectory)'
```




### Primo passo

Abbiamo due cartelle.
Queste cartelle contengono tutto ciò che serve: codice, binari, librerie, ecc.

Domanda da porsi: 
si vuole prendere **solo il codice sorgente** o **i binari già compilati**? 
Questo cambia leggermente l’approccio.

---
#### **Output desiderato**

Vuoi ottenere un unico file `.zip` che contenga entrambe le cartelle, così da poterlo usare come artefatto nella pipeline.

Esempio struttura zip:

```
Progetti.zip
├── ProgettoA/
│   └── tutti i file di ProgettoA
└── ProgettoB/
    └── tutti i file di ProgettoB
```

---

### **Passaggi logici 

1. **Preparare una cartella temporanea**
    
    - Dentro la pipeline, creare una cartella “intermedia” dove mettere le cartelle che vuoi zippare.
    - Questo aiuta a non mischiare altri file del repository.
        
2. **Copiare le cartelle dentro la cartella temporanea**
    
    - Qui puoi decidere se includere tutto o solo alcuni file (ad esempio solo `bin/Debug` se vuoi i binari).
        
3. **Creare lo zip**
    
    - Su Linux/Ubuntu: `zip -r Progetti.zip TempFolder/`
    - Su Windows: `Compress-Archive` di PowerShell
        
4. **Pubblicare lo zip 
    - Serve perché lo zip possa essere scaricato e usato
	
### Cose da considerare

- Se i progetti hanno **dipendenze**, potresti dover decidere se includerle nello zip o lasciare che vengano restore tramite NuGet/Node/etc.
    
- Se prevedi di usare questi progetti in container, la pipeline potrebbe anche estrarre lo zip e copiare i contenuti dentro il container.


possibile ordine
Trigger → checkout → setup Ambiente → restore (pacchetti) → build → raccolta binari → zip → publish 

oppure
Trigger → checkout → setup Ambiente → zip -> restore (pacchetti) → build → publish 

### conclusioni
la vmImage è ubuntu-latest.
alla fine tutto questo non serviva perche le soluzioni (progetti) non devono essere compilati, non serve fare 
```
    # Step 1: Setup .NET SDK
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '8.0.x'   # o la versione compatibile con i tuoi progetti
        installationPath: $(Agent.ToolsDirectory)/dotnet

    # Step 2: Restore pacchetti
    - script: dotnet restore $(solution)
      displayName: 'Restore NuGet Packages'

    # Step 3: Build solution
    - script: dotnet build $(solution) --configuration $(buildConfiguration) --no-restore
      displayName: 'Build Solution'


```

basta copiare in una zip unica i due progetti attraverso uno script powershell e successivamente fare la pubblicazione dello zip. 




# serialnumbers
https://temp.afm.vvf.priv/api/serial-number/swagger/index.html


https://temp.afm.vvf.priv/api/serial-number/swagger/index.html in base a quanto c'è nell'ingress... il wiki è da coreggere... al momento l'URL http://serial-numbers.afm.vvf.priv/swagger/index.html funziona solo per attachments... 

