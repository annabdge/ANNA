---
cssclasses:
  - mercoledi
tags:
---

mercoledi

### aks e URL swagger

| servizio       | stato        | indirizzo                                                                    | json                                                                    |
| -------------- | ------------ | ---------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| part-numbers   | errore parse | https://temp.afm.vvf.priv/api/partnumbers/swagger/index.html .               | https://temp.afm.vvf.priv/api/partnumbers/api/lookups/manufacturers     |
| serial-numbers | no           | dovrebbe su (https://temp.afm.vvf.priv/api/serialnumbers/swagger/index.html) |                                                                         |
| technical-pubs | ok           | https://temp.afm.vvf.priv/api/technicalpubs/swagger/index.html               |                                                                         |
| backend        | ok           | https://temp.afm.vvf.priv/api/afm-ms-backend/swagger/index.html              |                                                                         |
| frontend       | ok           | https://temp.afm.vvf.priv/                                                   |                                                                         |
| usermanager    | no           | https://temp.afm.vvf.priv/api/usermanager/swagger/index.html                 |                                                                         |
| profile        | errore parse | https://temp.afm.vvf.priv/api/profile/swagger/index.html ...                 | https://temp.afm.vvf.priv/api/profile/swagger/fleetprofile/swagger.json |

### pipeline
riportare una pipeline con stage di build buildx a una versione senza buildx.
sul branch master devo riportare le modifiche che proverò a fare prima in pipeline_try. qui è stato eseguito un passaggio da build normale a multiarch (buildx). si vuole tornare alla vecchia build normale. perchè? cosa significa? cosa a che fare con docker? se la versione di docker è esplicitata significa che è stata forzata per essere compatibile con la buildx. per tornare al build normale guardo tutti i passaggi fatti nelle pipeline dal 13 novembre ([Commit 602a8ac9](https://dev.azure.com/Leonardo-Cybersecurity/AFM-VVF/_git/VVF_BE_Attachments/commit/602a8ac9e3c983ab0b3987fd748976bf674cb583?refName=refs/heads/pipeline_try)) **Aggiustamenti e trigger su master** fino all'ultima che ha girato del 23 dicembre **Allineamento configurazione e deploy** ([Commit 7ffd23e1](https://dev.azure.com/Leonardo-Cybersecurity/AFM-VVF/_git/VVF_BE_Attachments/commit/7ffd23e19ec449e4ef8c8f2486f59b2ab03cf616?refName=refs/heads/pipeline_try)) però nel frattempo vorrei capire la logica di questa buildx, perche si fa, perche non si fa..

##### Che cos’è **buildx** e perché qualcuno l’ha introdotto
Docker buildx è un’estensione del comando `docker build` che serve principalmente a una cosa:
> *costruire immagini Docker per più architetture CPU* con una sola build.

Con build “normale” (`docker build`) ottieni:
- una sola architettura
- quella dell’host che builda (es. linux/amd64 sull’agent Azure)
    
Con buildx puoi ottenere:
- linux/amd64
- linux/arm64
- (eventualmente altre)  
    in un’unica immagine logica pubblicata nel registry come _manifest list_.
    
##### Perché si fa una build multi-arch (buildx)
Si introduce buildx quando una di queste condizioni è vera:
1. Il cluster (AKS, K8s, ecc.) gira su [nodi ARM]
2. L’immagine deve girare sia su x86 che su ARM
3. Si vogliono supportare:
    - Mac M1/M2
    - Raspberry
    - ambienti edge
4. L’organizzazione ha standard “enterprise” di portabilità
In questi casi buildx ha senso.
-
##### Perché NON si fa (e spesso si torna indietro)
Buildx **non è gratis**, introduce complessità reale:
- build più lente
- più punti di failure
- Docker forzato a una versione specifica
    - nel tuo caso: `20.10.24`
    - non è casuale → è per compatibilità buildx/QEMU    
- Build non più locale
    - niente immagine “fisica” sull’agent
    - push immediato
    - debugging più difficile
- Pipeline più fragile
    - più step
    - più dipendenze
    - più cose che possono rompersi

##### Collegamento diretto con Docker (punto chiave)
Hai centrato una cosa importantissima:
> “se la versione di docker è esplicitata significa che è stata forzata per essere compatibile con la buildx”

Nel momento in cui vedi:
- `DockerInstaller@0` con `dockerVersion: '20.10.24'`
- `docker buildx version`
- `tonistiigi/binfmt`
- `buildx create --use`
significa che:  
 la pipeline è stata piegata intorno a buildx**, non il contrario.
##### Cosa significa “tornare alla build normale”
Tecnicamente e concettualmente:
1. Una sola architettura**
    - amd64
    - quella dell’agent
2. Docker standard  
3. Build locale
    - `docker build` o `docker-compose build`
    - immagine disponibile sull’agent
4. Push esplicito
    - `docker tag`
    - `docker push`
È il modello classico, prevedibile, stabile.

##### pipeline dal 13 novembre in poi 
Perché lì è successo il cambio di paradigma
- prima: _build semplice_
- dopo: _build multiarch_
non è solo “togliere buildx” , ma: ricostruire l’ultima pipeline “buona” prima del cambio
e riallinearla alle piccole modifiche successive (path, imageRepository, context, trigger).

##### stage di build 
> “Una sola architettura (amd64, quella dell’agent)”

In questo stage non c’è nessun meccanismo che permetta di scegliere l’architettura.**  
Questo da solo basta a dire che la build è **monoarch**.
vediamo _perché_.
1.  L’architettura è implicita, non dichiarata
Qui:
```
pool:
  vmImage: $(vmImageName)
```

`ubuntu-latest` sugli agent Azure DevOps è:
- linux/amd64
- Docker installato per **amd64**

Non c’è:
- `--platform`
- `buildx`
- emulazione
> l’architettura dell’immagine coincide con l’architettura dell’agent.  

Questo è esattamente cosa significa “build normale”.

2. Docker “classico”, non forzato, non esteso

Questo step è fondamentale:
```
- task: DockerInstaller@0
  displayName: 'Install Docker'
```

Cosa _non_ vedi (ed è voluto):
- nessuna `dockerVersion`
- nessun controllo di compatibilità
- nessuna dipendenza da buildx
    
	Docker viene installato **così com’è**, nella versione supportata dall’agent.

Nelle pipeline buildx, invece, qui compariva:
- `dockerVersion: 20.10.24`
- verifiche `docker buildx version`

La loro **assenza** è un segnale forte:  
questa pipeline **non è pensata per multiarch**.

 3. La build dell’immagine avviene localmente

Questo è il cuore del modello monoarch:
```
docker-compose -f $(dockerComposeFile) up -d --build
```

Cosa succede realmente:

- `docker-compose build`
    - usa `docker build`
    - **senza `--platform`**
        
- l’immagine viene:
    - costruita **localmente**        
    - per l’architettura dell’host  
    - salvata nel Docker daemon dell’agent
        
una build = una architettura = un’immagine fisica

4. L’immagine esiste davvero sull’agent (punto chiave)

```
docker tag $(imageRepository):latest ...
docker push ...
```

Questo è impossibile con buildx, perché buildx:
- non lascia immagini locali
- push-a direttamente al registry
    
Qui invece:
- l’immagine `$(imageRepository):latest` esiste   
- viene taggata  
- viene pushata manualmente
    
Questo è **il modello Docker classico**, pre-buildx.

5. Nessun riferimento a multi-platform (prova definitiva)

In tutto lo stage non esiste:
- `docker buildx`
- `--platform`
- `linux/arm64`
- `tonistiigi/binfmt`
- `QEMU`
  
Questa assenza non è casuale:  
significa che non è nemmeno contemplata l’idea di più architetture.
Questo stage dice implicitamente:
> “Costruisco un’immagine Docker per questa macchina,  e la pubblico così com’è.”
Ed è esattamente ciò che intendevi quando parlavi di:

> “tornare alla build normale”

6. Conclusione netta
La natura mono-arch di questo stage è visibile perché:
1. l’architettura non è mai menzionata
2. Docker lavora come sempre
3. l’immagine nasce e vive sull’agent
4. il push è manuale e separato
    
morale. la parte piu noiosa è stata allineare i nomi dell'immagine docker e correggere il docker-compose.
cmq quella su try è ok, quella sul master ha nome diverso afm/attachments. è andata anche lei.

stesso lavoro su:
#### resoconto finale 

| <br>           | mono          | trigger  | stato |
| -------------- | ------------- | -------- | ----- |
| attachments    | mono          | master   | o     |
| backend_ias    | multi         | todeploy | o     |
| frontend       | mono (buildx) | dev      | o     |
| partnumbers    | multi         | dev      | X     |
| serialnumbers  | multi         | dev      | o     |
| installedparts | multi         | dev      | o     |
| technicalpubs  | multi         | dev      | o     |
| warehouse      | multi         | dev      | o     |
| usermanager    | mono (buildx) | dev      | o     |
| report         |               |          | X     |
